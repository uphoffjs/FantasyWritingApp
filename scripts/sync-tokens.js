#!/usr/bin/env node

/**
 * * Token Synchronization Script
 * * Syncs design tokens between React Native (TypeScript) and CSS
 * * Ensures consistency across mockups, Storybook, and React Native components
 */

const fs = require('fs');
const path = require('path');

// * File paths
const SHARED_STYLES_DIR = path.join(__dirname, '../src/shared-styles');
const MOCKUPS_CSS_DIR = path.join(__dirname, '../mockups/css');
const TS_TOKENS_FILE = path.join(SHARED_STYLES_DIR, 'fantasy-tokens.ts');
const _CSS_TOKENS_FILE = path.join(SHARED_STYLES_DIR, 'fantasy-tokens.css');
const MOCKUPS_SHARED_CSS = path.join(MOCKUPS_CSS_DIR, 'shared-tokens.css');

// * Colors mapping - maps TS color names to CSS variable names
const colorMapping = {
  // Primary colors
  might: 'color-might',
  swiftness: 'color-swiftness',
  vitality: 'color-vitality',
  finesse: 'color-finesse',
  
  // Neutral colors
  parchment: 'color-parchment',
  obsidian: 'color-obsidian',
  ink: 'color-ink',
  inkSecondary: 'color-ink-secondary',
  
  // Metallic accents
  gold: 'color-gold',
  silver: 'color-silver',
  bronze: 'color-bronze',
  copper: 'color-copper',
  
  // Semantic colors
  danger: 'color-danger',
  success: 'color-success',
  warning: 'color-warning',
  info: 'color-info',
  
  // Element colors
  character: 'color-character',
  location: 'color-location',
  magic: 'color-magic',
  item: 'color-item',
  creature: 'color-creature',
  culture: 'color-culture',
  organization: 'color-organization',
  religion: 'color-religion',
  technology: 'color-technology',
  history: 'color-history',
  language: 'color-language',
};

// * Typography mapping
const typographyMapping = {
  fontSize: {
    xs: 'font-size-xs',
    sm: 'font-size-sm',
    base: 'font-size-base',
    lg: 'font-size-lg',
    xl: 'font-size-xl',
    '2xl': 'font-size-2xl',
    '3xl': 'font-size-3xl',
    '4xl': 'font-size-4xl',
    '5xl': 'font-size-5xl',
  },
  fontWeight: {
    light: 'font-weight-light',
    normal: 'font-weight-normal',
    medium: 'font-weight-medium',
    semibold: 'font-weight-semibold',
    bold: 'font-weight-bold',
  },
  lineHeight: {
    tight: 'line-height-tight',
    snug: 'line-height-snug',
    normal: 'line-height-normal',
    relaxed: 'line-height-relaxed',
    loose: 'line-height-loose',
  },
};

// * Spacing mapping (8px grid)
const spacingMapping = {
  0: 'space-0',
  1: 'space-1',
  2: 'space-2',
  3: 'space-3',
  4: 'space-4',
  5: 'space-5',
  6: 'space-6',
  8: 'space-8',
  10: 'space-10',
  12: 'space-12',
  16: 'space-16',
  20: 'space-20',
  24: 'space-24',
  32: 'space-32',
};

// * Function to read the TypeScript tokens file and extract values
function readTSTokens() {
  try {
    const tsContent = fs.readFileSync(TS_TOKENS_FILE, 'utf-8');
    
    // * Extract colors using regex
    const colorRegex = /(\w+):\s*['"]#([A-F0-9]{6})['"]/gi;
    const colors = {};
    let match;
    
    while ((match = colorRegex.exec(tsContent)) !== null) {
      const [, name, hex] = match;
      if (colorMapping[name]) {
        colors[colorMapping[name]] = `#${hex}`;
      }
    }
    
    // * Extract font sizes
    const fontSizes = {};
    const fontSizeRegex = /fontSize:\s*{([^}]+)}/s;
    const fontSizeMatch = tsContent.match(fontSizeRegex);
    if (fontSizeMatch) {
      const sizeRegex = /['"]?([\w-]+)['"]?:\s*(\d+)/g;
      while ((match = sizeRegex.exec(fontSizeMatch[1])) !== null) {
        const [, name, size] = match;
        if (typographyMapping.fontSize[name]) {
          fontSizes[typographyMapping.fontSize[name]] = `${size / 16}rem`;
        }
      }
    }
    
    // * Extract spacing
    const spacing = {};
    const spacingRegex = /spacing\s*=\s*{([^}]+)}/s;
    const spacingMatch = tsContent.match(spacingRegex);
    if (spacingMatch) {
      const spaceRegex = /(\w+):\s*(\d+)/g;
      while ((match = spaceRegex.exec(spacingMatch[1])) !== null) {
        const [, name, pixels] = match;
        if (spacingMapping[name]) {
          spacing[spacingMapping[name]] = `${pixels / 16}rem`;
        }
      }
    }
    
    return { colors, fontSizes, spacing };
  } catch (error) {
    console.error('Error reading TypeScript tokens:', error);
    return null;
  }
}

// * Function to generate CSS from tokens
function generateCSS(tokens) {
  const { colors, fontSizes, spacing } = tokens;
  
  let css = `/**
 * * Synchronized Design Tokens from React Native
 * * Auto-generated by sync-tokens.js
 * * DO NOT EDIT MANUALLY - Edit src/shared-styles/fantasy-tokens.ts instead
 */

:root {
  /* * ========== COLORS ========== */
`;

  // * Add color variables
  for (const [name, value] of Object.entries(colors)) {
    css += `  --${name}: ${value};\n`;
  }
  
  css += `
  /* * ========== TYPOGRAPHY ========== */
`;

  // * Add font size variables
  for (const [name, value] of Object.entries(fontSizes)) {
    css += `  --${name}: ${value};\n`;
  }
  
  css += `
  /* * ========== SPACING ========== */
`;

  // * Add spacing variables
  for (const [name, value] of Object.entries(spacing)) {
    css += `  --${name}: ${value};\n`;
  }
  
  css += `}

/* * Import the main shared tokens file */
@import '../../src/shared-styles/fantasy-tokens.css';
`;
  
  return css;
}

// * Main sync function
function syncTokens() {
  console.log('📚 Starting token synchronization...');
  
  // * Read TypeScript tokens
  const tokens = readTSTokens();
  if (!tokens) {
    console.error('❌ Failed to read TypeScript tokens');
    return;
  }
  
  console.log(`✅ Read ${Object.keys(tokens.colors).length} colors`);
  console.log(`✅ Read ${Object.keys(tokens.fontSizes).length} font sizes`);
  console.log(`✅ Read ${Object.keys(tokens.spacing).length} spacing values`);
  
  // * Generate CSS
  const css = generateCSS(tokens);
  
  // * Write to mockups shared CSS
  try {
    fs.writeFileSync(MOCKUPS_SHARED_CSS, css);
    console.log(`✅ Updated ${MOCKUPS_SHARED_CSS}`);
  } catch (error) {
    console.error('❌ Failed to write mockups CSS:', error);
  }
  
  // * Update mockups to import the shared tokens
  const mockupsIndexPath = path.join(MOCKUPS_CSS_DIR, 'base.css');
  try {
    let baseCSS = fs.readFileSync(mockupsIndexPath, 'utf-8');
    
    // * Check if import already exists
    if (!baseCSS.includes('shared-tokens.css')) {
      // * Add import at the top
      baseCSS = `/* * Import shared design tokens */\n@import 'shared-tokens.css';\n\n` + baseCSS;
      fs.writeFileSync(mockupsIndexPath, baseCSS);
      console.log('✅ Updated base.css to import shared tokens');
    }
  } catch (error) {
    console.error('⚠️  Could not update base.css:', error.message);
  }
  
  console.log('🎉 Token synchronization complete!');
}

// * Watch mode
if (process.argv.includes('--watch')) {
  console.log('👀 Watching for changes...');
  fs.watchFile(TS_TOKENS_FILE, { interval: 1000 }, () => {
    console.log('🔄 Detected changes in TypeScript tokens...');
    syncTokens();
  });
  
  // * Initial sync
  syncTokens();
} else {
  // * Run once
  syncTokens();
}